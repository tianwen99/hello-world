给定一个5位的正整数，打印万位、千位、百位、十位、个位
num=54321
1.54321//10000=5,54321%10000=4321
2.4321//1000=4,4321%1000=321
3.321//100=3,321%100=21
4.21//10=2,21%10=1
5.1//1=1,1%1=0

num=int(input(<<<))
lnum=len(str(num))
w=10000
for i in rang(lnum):
  print(num//w)
  num%=w
  w//=10



若是num=00500,打印500

num=00500 #int
n=6 #几位数
w=10**(n-1)
flag=False #假定还没有碰到第一个非零
for i in rang(n):
  y=num//w
  if flag or y:
    print(y)
    flag=True #从此开关打开
  num=num%w
  w=w//10

给定不超过5位的正整数，打印个、十、百、千、万位
1.54321//10=5432,54321-5432*10=1
2.5432//10=543,5432-543*10=2
3.543//10=54,543-54*10=3
4.54//10=5,54-5*10=4
5.5//10=0,5-0*10=5



数字的处理函数：
min(x,y)取最小
max(x,y)取最大
pow(x,y)=x**y
math.sqrt(x)=开x次方

进制相关函数：返回的是字符串
bin（）二进制
Oct（）八进制
hex（）16进制

类型判定：
type(obj),返回类型，不是字符串
isinstance(16,int)=Ture
isinstance(16,(int,str))=True
isinstance(16,(str,float))=False


列表list:有序队列，每个元素有索引，从0开始，有序就可索引。线性的数据结构。列表是可变得。内存中是挨着连续的。查询快，增和删比较慢（查比链表效率高），查比较快，修改比较慢。
list：可变的、可索引的、有序的、可迭代的、多类型的
链表：手拉手，可以站圆圈。有顺序的，可以索引，在内存中有可能是散落的。问题在找的慢，修改增和删比较好（插队或去掉在两边重新拉手就可以，不过还是先找，比较慢）
queue队列：先进先出队列，用在你拿元素吧，不是拿来增删插改的。
stack栈队列：先进后出队列，子弹夹原理。

lis=[]
lis=list(一个可迭代对象)
lis=[1,2]
lis=list(range(5))=[0,1,2,3,4]
lis=[range(5)]=[range(0,5)]
list列表是可迭代对象,不支持一开始就定义大小。索引超界报异常：IndexError

列表查询：
index（value，[start,[stop]]）:通过值，从指定区间查找列表内的元素是否匹配，匹配第一个就立即返回索引，匹配不到就抛出异常ValueError，找不到要遍历一遍，要少用。
变量a
a.index(元素)=索引下标

count（value）：返回列表中匹配Value的次数，要遍历一遍，很慢，要少用。
a.count（元素）=有多少个元素

时间复杂度：index和count方法都是O（n），随着列表数据规模的增大而效率下降。

len()：列表的长度。


列表元素修改：
索引访问修改：list[index]=Value
索引不要超界。

列表增加、插入元素：
append（object）-》None
1.列表尾部追加元素，返回None
2.返回None就意味着没有新的列表产生，就地修改。
3.时间复杂度是O(1):一步到位，很快。

insert（index，object）-》None
1.在指定索引出入元素object
2.时间复杂度O（n）
3.超上界，尾部加
4.超下界，头部加。


extend（iteratable）-》None
将可迭代的对象元素追加进来，返回None，就地修改

+ -》list：产生新的列表，原列表不变，本至上调用的是_add_（）方法

* -》list：重复操作，返回新的列表，原列表不变。


newlist=[[1,2]]*3=[[1,2],[1,2],[1,2]]其中[1,2]的内存地址是一样的，要改的话所有都变。（*是复制3次）
newlist=[1,2]*3=[1,2,1,2,1,2]这是不同的地址，改的话只变1个（单值的列表只改1个）


列表删除元素：
remove（value）-》none
从左至右查找第一个匹配value的值并移除该元素，返回none，就地修改。效率不高。

pop（[index]）-》item
不写索引，就从尾部弹出一个元素
有索引，就从索引处弹出一个元素，索引超界抛出indexError
效率：有索引，不高。没有索引，很高。


clear（）-》none
清除所有元素，剩一个空列表。

列表其他操作：
reverse（）-》none
将列表元素反转（倒打印），返回none，就地修改

sort（key=none,reverse=False）->none
对列表进行比较大小后进行排序，默认升序，key是修改类型，不同类型则可以进行比较，但是不会修改元素的类型，只是为了能比较大小而排序而已，不然不同类型不能比较大小而报错。


value in list：只对内容比较。



浅拷贝、深拷贝：
当列表里有复杂的引用类型list1=[[2,3],1,2,4,5],其中[2,3]就是复杂的类型，当list2=list1.copy(),[2,3]里指向的内存地址是一样的，当改list2时，list1也会变，这种叫浅拷贝，要特别注意这种引用类型。

如果我拷贝过来，各种改各自的，互不影响，就要用深拷贝：需要引用模块：
import copy #模块
list2=copy.deepcopy(list1) #往后怎么改都是互不影响。


随机数：
random模块：random.--
ranint（a,b）：返回[a,b]之间的整数。

choice（seq）:从非空序列的元素中随机挑选一个元素，比如random.choice(range(10)),从0到9中随机挑选一个整数，random.choice([1,2,4,5])

randrange([start,]stop[,step])从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值（默认值）为1，random.ranrange(1,7,2)


random.shuffle(list)->none:就地打乱列表元素。

random.sample(population,k)从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回一个新列表,k不能超出样本数，否则报错。
random.sample([2,3,1,4],2),random.sample((3,2,4,5)，3)
random.sample([‘a’,'a'],2)


元组

元组不支持赋值语句
一旦定义就不可改变

t=tuple(range(5))
t=tuple(list(range(5)))
t=tuple([2,1,6,7])
l=list(tuple(range(10))),里面内容可以改
列表和元组可以转换，容器都是可迭代对象。
l=list(1,2,6)这是错的，list里是一个可迭代对象，里面是3个元素，不是一个可迭代对象。
l=list((1,2,6))才是对的。

一个元素的元组
t=(3)=3这不是元组
t=(3,)=(3，）是元组


元组相加、乘，返回新的元组，原元组不变。

元组的访问除了不可赋值改变，其他与列表一样。


命名元组
from collection（集合） import namedtuple
point = namedtuple('_p','x y'):'_p'是类型名,可以随便定义，要字符串类型，‘x y’是字段属性，可以是列表、元组，中间可以用逗号，空格。
p1=point(4,5)=_p(x=4,y=5)
p1.x=4
p1.y=5




练习：依次接收用户输入的3个数，排序后打印
1.转换int后，判断大小排序。使用分支结构（if else结构）完成。
2.使用max函数
3.使用列表的sort方法
4.冒泡法（优化）

5.100以内的所有素数的个数



         














































































































































































