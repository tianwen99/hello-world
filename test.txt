给定一个5位的正整数，打印万位、千位、百位、十位、个位
num=54321
1.54321//10000=5,54321%10000=4321
2.4321//1000=4,4321%1000=321
3.321//100=3,321%100=21
4.21//10=2,21%10=1
5.1//1=1,1%1=0

num=int(input(<<<))
lnum=len(str(num))
w=10000
for i in rang(lnum):
  print(num//w)
  num%=w
  w//=10



若是num=00500,打印500

num=00500 #int
n=6 #几位数
w=10**(n-1)
flag=False #假定还没有碰到第一个非零
for i in rang(n):
  y=num//w
  if flag or y:
    print(y)
    flag=True #从此开关打开
  num=num%w
  w=w//10

给定不超过5位的正整数，打印个、十、百、千、万位
1.54321//10=5432,54321-5432*10=1
2.5432//10=543,5432-543*10=2
3.543//10=54,543-54*10=3
4.54//10=5,54-5*10=4
5.5//10=0,5-0*10=5



数字的处理函数：
min(x,y)取最小
max(x,y)取最大
pow(x,y)=x**y
math.sqrt(x)=开x次方

进制相关函数：返回的是字符串
bin（）二进制
Oct（）八进制
hex（）16进制

类型判定：
type(obj),返回类型，不是字符串
isinstance(16,int)=Ture
isinstance(16,(int,str))=True
isinstance(16,(str,float))=False


列表list:有序队列，每个元素有索引，从0开始，有序就可索引。线性的数据结构。列表是可变得。内存中是挨着连续的。查询快，增和删比较慢（查比链表效率高），查比较快，修改比较慢。
list：可变的、可索引的、有序的、可迭代的、多类型的
链表：手拉手，可以站圆圈。有顺序的，可以索引，在内存中有可能是散落的。问题在找的慢，修改增和删比较好（插队或去掉在两边重新拉手就可以，不过还是先找，比较慢）
queue队列：先进先出队列，用在你拿元素吧，不是拿来增删插改的。
stack栈队列：先进后出队列，子弹夹原理。

lis=[]
lis=list(一个可迭代对象)
lis=[1,2]
lis=list(range(5))=[0,1,2,3,4]
lis=[range(5)]=[range(0,5)]
list列表是可迭代对象,不支持一开始就定义大小。索引超界报异常：IndexError

列表查询：
index（value，[start,[stop]]）:通过值，从指定区间查找列表内的元素是否匹配，匹配第一个就立即返回索引，匹配不到就抛出异常ValueError，找不到要遍历一遍，要少用。
变量a
a.index(元素)=索引下标

count（value）：返回列表中匹配Value的次数，要遍历一遍，很慢，要少用。
a.count（元素）=有多少个元素

时间复杂度：index和count方法都是O（n），随着列表数据规模的增大而效率下降。

len()：列表的长度。


列表元素修改：
索引访问修改：list[index]=Value
索引不要超界。

列表增加、插入元素：
append（object）-》None
1.列表尾部追加元素，返回None
2.返回None就意味着没有新的列表产生，就地修改。
3.时间复杂度是O(1):一步到位，很快。

insert（index，object）-》None
1.在指定索引出入元素object
2.时间复杂度O（n）
3.超上界，尾部加
4.超下界，头部加。


extend（iteratable）-》None
将可迭代的对象元素追加进来，返回None，就地修改

+ -》list：产生新的列表，原列表不变，本至上调用的是_add_（）方法

* -》list：重复操作，返回新的列表，原列表不变。


newlist=[[1,2]]*3=[[1,2],[1,2],[1,2]]其中[1,2]的内存地址是一样的，要改的话所有都变。（*是复制3次）
newlist=[1,2]*3=[1,2,1,2,1,2]这是不同的地址，改的话只变1个（单值的列表只改1个）


列表删除元素：
remove（value）-》none
从左至右查找第一个匹配value的值并移除该元素，返回none，就地修改。效率不高。

pop（[index]）-》item
不写索引，就从尾部弹出一个元素
有索引，就从索引处弹出一个元素，索引超界抛出indexError
效率：有索引，不高。没有索引，很高。


clear（）-》none
清除所有元素，剩一个空列表。

列表其他操作：
reverse（）-》none
将列表元素反转（倒打印），返回none，就地修改

sort（key=none,reverse=False）->none
对列表进行比较大小后进行排序，默认升序，key是修改类型，不同类型则可以进行比较，但是不会修改元素的类型，只是为了能比较大小而排序而已，不然不同类型不能比较大小而报错。


value in list：只对内容比较。



浅拷贝、深拷贝：
当列表里有复杂的引用类型list1=[[2,3],1,2,4,5],其中[2,3]就是复杂的类型，当list2=list1.copy(),[2,3]里指向的内存地址是一样的，当改list2时，list1也会变，这种叫浅拷贝，要特别注意这种引用类型。

如果我拷贝过来，各种改各自的，互不影响，就要用深拷贝：需要引用模块：
import copy #模块
list2=copy.deepcopy(list1) #往后怎么改都是互不影响。


随机数：
random模块：random.--
ranint（a,b）：返回[a,b]之间的整数。

choice（seq）:从非空序列的元素中随机挑选一个元素，比如random.choice(range(10)),从0到9中随机挑选一个整数，random.choice([1,2,4,5])

randrange([start,]stop[,step])从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值（默认值）为1，random.ranrange(1,7,2)


random.shuffle(list)->none:就地打乱列表元素。

random.sample(population,k)从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回一个新列表,k不能超出样本数，否则报错。
random.sample([2,3,1,4],2),random.sample((3,2,4,5)，3)
random.sample([‘a’,'a'],2)


元组

元组不支持赋值语句
一旦定义就不可改变

t=tuple(range(5))
t=tuple(list(range(5)))
t=tuple([2,1,6,7])
l=list(tuple(range(10))),里面内容可以改
列表和元组可以转换，容器都是可迭代对象。
l=list(1,2,6)这是错的，list里是一个可迭代对象，里面是3个元素，不是一个可迭代对象。
l=list((1,2,6))才是对的。

一个元素的元组
t=(3)=3这不是元组
t=(3,)=(3，）是元组


元组相加、乘，返回新的元组，原元组不变。

元组的访问除了不可赋值改变，其他与列表一样。


命名元组
from collection（集合） import namedtuple
point = namedtuple('_p','x y'):'_p'是类型名,可以随便定义，要字符串类型，‘x y’是字段属性，可以是列表、元组，中间可以用逗号，空格。
p1=point(4,5)=_p(x=4,y=5)
p1.x=4
p1.y=5




练习：依次接收用户输入的3个数，排序后打印
1.转换int后，判断大小排序。使用分支结构（if else结构）完成。
2.使用max函数
3.使用列表的sort方法
4.冒泡法（优化）

5.100以内的所有素数的个数


字符串：字面常量，不可变。
字符串里有转义，\t \n \\,字符串外面加R，r就不会转义。
是一个有顺序的序列，有下标索引，空格或标点符号也有下标。
可迭代
sql='qas'
lis=list(sql)

字符串join连接
1.‘str’.join(iterable)->str,返回一个新字符串。
2.可迭代对象本身是字符串。
lst=['1','2','3']
print("\"".join(lst))#分隔符是"
当lst=['1',['1','2'],'3'],用了会出错，因为第二个不是字符串类型，是个列表。

join：用什么东西把谁（字符串）给连起来。
','.join(sql)='q,a,s'
','.join(map(str,range(10)))
 

字符串+连接：返回一个新字符串。

字符串分割：split(sep=none,maxsplit=-1)->list of strings
1.从左至右
2.sep指定分割字符串，缺省的情况下空白字符串作为分隔符。
3.maxsplit指定分割次数，-1表示遍历整个字符串。

split：将字符串按照分隔符分割成若干字符串，并返回列表。缺省是不可见空白或空白+
"a,b,c".split(",")=["a","b","c"]
split（maxsplit=1,0，-1,2）（切几刀）
.split(sep=“\n”)以换行符切
.rsplit()从右边开始切

splitlines([keepends])->list of strings
1.按照行来切分字符串。
2.keepends指是否保留行分隔符。
3.行分隔符包括：\n、 \r\n、 \r等
'\n'.splitlines():按换行符切，\r \n

partition：将字符串按照分隔符（一定要用分割符）分割成2段，返回这2段和分隔符的元组。没有找到分割符就返回头，2个空元素的三元组。
“1a2a3a”.partition('a')=('1','a','2a3a')

字符串大小写：
upper（）：全大写

lower（）：全小写

swapcase（）：交互大小写，把大写转小写。


字符串排版：
a='aaa bbb ccc'
title（）-》str，每个首字母大写a.title()='Aaa Bbb Ccc'

capitalize()：首个单词大写=‘Aaa bbb ccc’

center(width[,fillchar]):width是打印宽度，fillchar是填充字符。

zfill(width):居右，左边用0填充。

ljust(width[,fillchar]):左对齐

rjust(width[,fillchar]):右对齐

字符串修改：
replace（old，new[,count]）:字符串中找到匹配替换为新的字符串，count表示替换几次。

strip（[chars]）:从字符串两端去除指定字符集chars中所有的字符，从两端找，当找到不在字符集里就停下来。没有指定，去除两端空白。

lstrip([chars]):左边找

rstrip([chars]):右边找

字符串查找：
find（sub[,start[,enf]]）->int
在指定区间[start,end)，从左到右，查找子串sub。找到返回索引，没找到返回-1.

rfind（sub[,start[,enf]]）：从右到左找......

index（sub[,start[,enf]]）:与find用法一样，但是找不到会抛出异常。


index和count方法都是O（n）

count（sub[,start[,enf]）：在指定区间[start,end)，从左到右，统计子串sub出现次数。

字符串判断：
endswith(suffix[,start[,end]])->bool,:在指定区间[start,end),字符串是否是suffix结尾。
startswith(prefix[,start[,end]]):在指定区间，字符串是否是以prefix开头。


字符串判断is系列：

isalnum()->bool:是否是字母和数字组成

isalpha()是否是字母组成
isdecima()是否只包含十进制数字
isdigit()是否全部数字
isidentifier()是否字母和下划线开头，其他都是字母、数字、下划线。
islower()是否全部是小写
isupper()是否全部是大写
isspace()是否只包含空白字符

字符串格式化：
字符串格式化是一种拼接字符串输出样式手段。
join拼接只能使用分隔符，且要求被拼接的是可迭代对象。
+拼接字符还算方便，但是非字符需要先转换为字符才能拼接。

格式要求：
	占位符：使用%和格式字符组成，例如%s、%d等。
	占位符中还可加入修饰符，例如%03d表示打印3个位置，不够前面补0.
	format % values，格式字符串和被格式之间使用%分隔。
	values只能是一个对象，或是一个和格式字符串占位符数目相等的元组，或一个字典。

字符串格式化：
format函数格式字符串语法：
‘{}{XXX}’.format（*args,**kwargs）->str
args是位置参数，是一个元组。
kwargs是关键字参数，是一个字典。
花括号表示占位符。
{}表示安照顺序匹配位置参数，{n}表示取位置参数索引为n的值。
{XXX}表示在关键字参数中搜索名称一致的。
{{}}表示打印花括号。

对齐

进制

浮点数


字符串练习：
用户输入一个数字，判断是几位数。
打印每一个数字，个十百千。。
打印每一个数字及其重复次数

输入5个数，打印每个数的位数，将这些数升序打印。





















































































































































































































































