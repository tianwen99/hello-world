给定一个5位的正整数，打印万位、千位、百位、十位、个位
num=54321
1.54321//10000=5,54321%10000=4321
2.4321//1000=4,4321%1000=321
3.321//100=3,321%100=21
4.21//10=2,21%10=1
5.1//1=1,1%1=0

num=int(input(<<<))
lnum=len(str(num))
w=10000
for i in rang(lnum):
  print(num//w)
  num%=w
  w//=10



若是num=00500,打印500

num=00500 #int
n=6 #几位数
w=10**(n-1)
flag=False #假定还没有碰到第一个非零
for i in range(n):
  y=num//w
  if flag or y:
    print(y)
    flag=True #从此开关打开
  num=num%w
  w=w//10

给定不超过5位的正整数，打印个、十、百、千、万位
1.54321//10=5432,54321-5432*10=1
2.5432//10=543,5432-543*10=2
3.543//10=54,543-54*10=3
4.54//10=5,54-5*10=4
5.5//10=0,5-0*10=5



数字的处理函数：
min(x,y)取最小
max(x,y)取最大
pow(x,y)=x**y
math.sqrt(x)=开x次方

进制相关函数：返回的是字符串
bin（）二进制
Oct（）八进制
hex（）16进制

类型判定：
type(obj),返回类型，不是字符串
isinstance(16,int)=Ture
isinstance(16,(int,str))=True
isinstance(16,(str,float))=False


列表list:有序队列，每个元素有索引，从0开始，有序就可索引。线性的数据结构。列表是可变得。内存中是挨着连续的。查询快，增和删比较慢（查比链表效率高），查比较快，修改比较慢。
list：可变的、可索引的、有序的、可迭代的、多类型的
链表：手拉手，可以站圆圈。有顺序的，可以索引，在内存中有可能是散落的。问题在找的慢，修改增和删比较好（插队或去掉在两边重新拉手就可以，不过还是先找，比较慢）
queue队列：先进先出队列，用在你拿元素吧，不是拿来增删插改的。
stack栈队列：先进后出队列，子弹夹原理。

lis=[]
lis=list()
lis=[1,2]
lis=list(range(5))=[0,1,2,3,4]
lis=[range(5)]=[range(0,5)]
list列表是可迭代对象,不支持一开始就定义大小。索引超界报异常：IndexError

列表查询：
index（value，[start,[stop]]）:通过值，从指定区间查找列表内的元素是否匹配，匹配第一个就立即返回索引，匹配不到就抛出异常ValueError，找不到要遍历一遍，要少用。
变量a
a.index(元素)=索引下标

count（value）：返回列表中匹配Value的次数，要遍历一遍，很慢，要少用。
a.count（元素）=有多少个元素

时间复杂度：index和count方法都是O（n），随着列表数据规模的增大而效率下降。

len()：列表的长度。


列表元素修改：
索引访问修改：list[index]=Value
索引不要超界。

列表增加、插入元素：
append（object）-》None
1.列表尾部追加元素，返回None
2.返回None就意味着没有新的列表产生，就地修改。
3.时间复杂度是O(1):一步到位，很快。

insert（index，object）-》None
1.在指定索引出入元素object
2.时间复杂度O（n）
3.超上界，尾部加
4.超下界，头部加。


extend（iteratable）-》None
将可迭代的对象元素追加进来，返回None，就地修改

+ -》list：产生新的列表，原列表不变，本至上调用的是_add_（）方法

* -》list：重复操作，返回新的列表，原列表不变。












































































